# Api Gateway and Accesstoken pattern in Microservice Architecture
####Project Description
This project demonstrates the gateway pattern and access token pattern used 
in Microservice Architecture by using Zuul as the gateway server and JWT as 
access token generated by the gateway (after authenticating the user)  and 
are passed along with requests to communicate the identity of the requestor to the 
services that handle the request. These services can use this JWT token if required in 
their calls to other services. 

##Background
##What are Api Gateway and Access token patterns and why do we need them?
###Api Gateway
There are many reasons one would want to use gateways, some of the main reasons are below:
1.  Gateways act as single point of entry into your application just like a gate of your home.
2.  All requests would be handled by the Gateway servers and are forwarded to the appropriate services.
    Just knowing the domain name of the gateway services would be enough rather than knowing the domain names of 
    other services.
3.  Gateways being the entry point for all the requests could authenticate, filter, monitor requests.
    This helps in separating the certain concerns (like security, analytics...) from the other services.
4.  Gateway can also act as load balancers. 
5.  They can also be configured to handle errors if things go wrong like if a certain service becomes unavailable,
    Gateways could use the cache for responding to certain requests.
    
   And this list goes on .....

If you want to dig deep [this is a good place to start](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/).

###Access token
Now that you have used api gateway for authenticating the requests and requests are now being forwarded 
to the microservices. Let's say microservices behind the gateway would like to know the identity of the requestor
(one who made the request). How would the gateway communicate this identity to the microservices? 

The Gateway would authenticate the request and passes the access token (like Jwt) that identities the
requestor in each request to the microservices. These access tokens can be passed in requests among microservices.

Image below shows a basic architecture of the pattern

![](https://lh6.googleusercontent.com/mmB3N-e6V6cVLX8PDn1ebMIx1DC3ZdhEt0Fo5ODmq7mW0pXZ964iFMqiBo9ZCL7YILT15WLDc5jpAQ=w1920-h902)

##Implementation
This project demonstrates the pattern on high level by using four different services:
1.  Zuul Gateway Service
2.  UI service (UI microservice for providing UI files like html,css,js)
3.  Spring boot REST api service ( API microservice )
4. Redis ( in-memory database for storing sessions )

In this project, `redis` is used to maintain and manage session data. In this we have centralized session
management so that in future if the zuul gateway service scales up, there would not be problem of 
session validation errors as we are maintaining session objects centrally in `redis` rather than maintaining 
on the gateway instance itself. So a request could be handled by any gateway service instance.

This is the architecture implemented:

![](https://lh3.googleusercontent.com/r23E1sfvDDOUADnilST-aaljfgF9vwCnjQ0jWb8SZAKlCMDiGejiI3rHYMu-mGJEkuyMdFp6XJGGEg=w1920-h902)

##Running the project
Things that are required for running the project:
1. docker
2. `Twilio verify` service account for sending/verifying OTP (For more information https://www.twilio.com/docs/verify/api).
    Insert the twilio account_sid, auth_token, service_sid in the `docker-compose.yml` under zuulgateway service environment
    variables.

        environment:
            - twilio.account_sid=your_twilio_account_sid
            - twilio.auth_token=your_twilio_auth_token
            - twilio.service_sid=your_verifyservice_sid


Run the following command inside the root folder and this would take couple of minutes depending
 on your network speed ...

`docker-compose up --build`

Re run the command if you encounter some issue and that should be able to solve it.

Open the url http://localhost:3456/ui in your browser

You would see a kind of raw ui.
It has two buttons one hits the unsecured api and the other hits the secured api and
the api responses would be appearing in `green color` text on the UI.
If secured api button is used it would prompt for authentication if not authenticated.

The authentication used in this project is Mobile OTP authentication.
`Enter the mobile number along with country code excluding '+' symbol`. Example for Indian mobile number
would be something like this 919440XXXXXX. Enter the OTP received for authentication. Now hit the secure button
and response should be successfully fetched.

####What happening behing the scenes?
For every request zuul gateway runs a set of security filters and if the api resource is secured 
and the request is not authenticated, it would throw `401 UNAUTHORIZED`. Gateway has set of end points for performing authentication.
Before making request to secure endpoints, a separate request has to made for authenticating user, in this case otp login.
The gateway authenticates the user and creates a session object, it will also create and stores a jwt token identifying the user for the session in the session object 
and this session object is stored onto redis and sends `set-cookie` with key SESSIONID back in the response to the request so that subsequent requests would contain
a COOKIE with key SESSIONID whose value has sessionid that is authenticated. When all the checks are done it's time for forwarding request to the appropriate server and
before forwarding the request Jwt token is retrieved from session object  and inserted into the request to the service, the service upon receiving the request will validate
the Jwt token and if successfully validated, the request is processed or else  `401 UNAUTHORIZED` is thrown back in the response.

#####Reasons for Zuul and JWT:

Zuul is one of the open source powerful libraries and many custom authentication filters can be
programmatically developed using it.

JWT access token is stateless and can be easily verified 
thus increasing the efficiency in authentication and authorization. Moreover JWT token is shared 
within the  network of microservices only. Assuming that all the services using https,
Jwt provides the secure and efficient way of communicating the identity of the requestor.